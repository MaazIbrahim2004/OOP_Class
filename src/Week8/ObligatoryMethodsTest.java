
import java.util.*;

public class ObligatoryMethodsTest {

	public static void main(String[] args) {
		
		/*Dog myDog = new Dog("Rosie", "C:/pictures/rosie.jpg");
		// The following two lines have the same effect.
		// remove the ToString() method from Dog class and see the result
		// then add it again and see the result. 
		System.out.println(myDog);
		System.out.println(myDog.toString());
		System.out.println("___________________");
	
		Dog herDog = new Dog("Rosie", "C:/pictures/rosie.jpg");
		Dog yourDog = myDog;
		
		System.out.println (yourDog.equals(myDog));
		System.out.println (herDog.equals(myDog));*/
		// Run this part twice: once without overridden equals() and once with overridden equals().
		/*System.out.println("___________________");
		OnlyPrimitives obj1 = new OnlyPrimitives(10, 'A');
		OnlyPrimitives obj2 = new OnlyPrimitives(10, 'A');
		OnlyPrimitives obj3 = obj1;

		System.out.println (obj1.equals(obj2));
		System.out.println (obj1.equals(obj3));*/
		
	/*	System.out.println("___________________");
		// Run this part twice: once without overridden equals() and once with overridden equals().		
		NonPrimitives obj4 = new NonPrimitives(10, "A");
		NonPrimitives obj5 = new NonPrimitives(10, "A");
		NonPrimitives obj6 = obj4;
		System.out.println (obj4.equals(obj5));
		System.out.println (obj4.equals(obj6));
		System.out.println("___________________");*/

		/*// Run this part twice: once without overridden equals() and once with overridden equals().		
		ArrayList<String> arr = new ArrayList<String>();
		arr.add("A");
		arr.add("B");
		ComplexNonPrimitives obj7 = new ComplexNonPrimitives(10, arr);
		ComplexNonPrimitives obj8 = new ComplexNonPrimitives(10, arr);
		ComplexNonPrimitives obj9 = obj7;
		System.out.println (obj7.equals(obj8));
		System.out.println (obj7.equals(obj9));
		System.out.println("___________________");*/
		
		/* please note that if you convert obj1.hashCode() to hexadecimal, 
		 * you get what is returned by obj1.toString(). i.e. the address of the object in memory 
		 */
		OnlyPrimitives obj10 = new OnlyPrimitives(10, 'A');
		OnlyPrimitives obj20 = new OnlyPrimitives(10, 'A');
		OnlyPrimitives obj30 = obj10;
		System.out.println(obj10.hashCode() + "\t" + obj20.hashCode() + "\t" + obj30.hashCode());
		System.out.println(obj10);
		
		/* comment out the code that I've written for equals() and 
		 * uncomment the code that is generated by eclipse for equals() and 
		 * hashCode() for OnlyPrimitives class and run the code again and see 
		 * the values of hash code for obj1, obj2, and obj3.
		 * Now they all should be the same. 
		 */
		
	}

}

/**
 * This class is designed to have only primitive attributes
 * It is designed to test equals() method
 *
 */
class OnlyPrimitives{
	int firstAttribute; 
	char secondAttribute;
	/**
	 * This is the default constructor.
	 */
	public OnlyPrimitives() {
		firstAttribute = 0; 
		secondAttribute = ' ';		
	}
	/**
	 * This is an overloaded constructor that gets two parameter to initialize the attributes.
	 * @param first is the initial value for the first attribute
	 * @param second is the initial value for the second attribute
	 */
	public OnlyPrimitives(int first, char second) {
		firstAttribute = first; 
		secondAttribute = second;
	}
	/**
	 * eclipse generated hashCode(). click on source menu -> choose generate hashCode() and equals()
	 */
/*	
	@Override
	public int hashCode() {
		// class Objects is in java.util. please note this is 'Objects', which is different from 'Object'
		return Objects.hash(firstAttribute, secondAttribute);
	}
	*/
	/**
	 * eclipse generated equals(). click on source menu -> choose generate hashCode() and equals()
	 */
	
/*	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		OnlyPrimitives other = (OnlyPrimitives) obj;
		return firstAttribute == other.firstAttribute && secondAttribute == other.secondAttribute;
	}
*/
	/*
	@Override
	public boolean equals (Object object) {
		// here first you need to make sure if object is of type OnlyPrimitives and therefore can be casted. 
		OnlyPrimitives obj = (OnlyPrimitives) object;
		if (firstAttribute == obj.firstAttribute && secondAttribute == obj.secondAttribute)
			return true; 
		else return false;
	}
	
	@Override
	public int hashCode() {
		return hashCode();
	}
	*/

}

/**
 * This class is designed to have primitive and non-primitive attributes
 * It is designed to test equals() method

 *
 */
class NonPrimitives{
	int firstAttribute; 
	String secondAttribute;
	/**
	 * This is the default constructor.
	 */
	public NonPrimitives() {
		firstAttribute = 0; 
		secondAttribute = "";		
	}
	/**
	 * This is an overloaded constructor that gets two parameter to initialize the attributes.
	 * @param first is the initial value for the first attribute
	 * @param second is the initial value for the second attribute
	 */
	public NonPrimitives(int first, String second) {
		firstAttribute = first; 
		secondAttribute = new String(second);
	}
	/**
	 * Overrides equals() method to check for the equality of the states of the objects
	 * @param obj an object of this class
	 * @return true if the states of this object is equal to the states of obj, otherwise returns false.
	 */
	public boolean equals (Object object) {
		// here first you need to make sure if object is of type NonPrimitives and therefore can be casted. 
		NonPrimitives obj = (NonPrimitives) object;
		boolean equal = false;
		if (obj != null)
			if (firstAttribute == obj.firstAttribute && secondAttribute.compareTo(obj.secondAttribute) == 0)
				equal = true; 
		return equal;
	}

	
}

/**
 * This class is designed to have primitive and complex on-primitive attributes
 * It is designed to test equals() method
 *
 */
class ComplexNonPrimitives{
	int firstAttribute; 
	ArrayList<String> secondAttribute;
	/**
	 * This is the default constructor.
	 */
	public ComplexNonPrimitives() {
		firstAttribute = 0; 
		secondAttribute = new ArrayList<String>();		
	}
	/**
	 * This is an overloaded constructor that gets two parameter to initialize the attributes.
	 * @param first is the initial value for the first attribute
	 * @param second is the initial value for the second attribute
	 */
	public ComplexNonPrimitives(int first, ArrayList<String> second) {
		firstAttribute = first; 
		secondAttribute = new ArrayList<String>();
		for (String obj:second) {
			secondAttribute.add(new String(obj));
		}
	}
	/**
	 * Overrides equals() method to check for the equality of the states of the objects
	 * @param obj an object of this class
	 * @return true if the states of this object is equal to the states of obj, otherwise returns false.
	 */
	public boolean equals (Object object) {
		// here first you need to make sure if object is of type ComplexPrimitives and therefore can be casted. 
		ComplexNonPrimitives obj = (ComplexNonPrimitives) object;
		boolean equal = (obj != null && this.secondAttribute.size() == obj.secondAttribute.size() && 
				         this.firstAttribute == obj.firstAttribute);
		if (equal)
			for (int i = 0; i < obj.secondAttribute.size(); i++) 
				if (secondAttribute.get(i).compareTo(obj.secondAttribute.get(i)) != 0) {
					equal = false; 
					break;
				}
		return equal;
	}
}



